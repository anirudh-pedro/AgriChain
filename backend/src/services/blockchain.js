const { Gateway, Wallets } = require('fabric-network');
const FabricCAServices = require('fabric-ca-client');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

class BlockchainService {
  constructor() {
    this.gateway = null;
    this.network = null;
    this.contract = null;
    this.wallet = null;
    this.connectionProfile = null;
    
    // Configuration
    this.channelName = process.env.FABRIC_CHANNEL || 'mychannel';
    this.chaincodeName = process.env.FABRIC_CHAINCODE || 'agrichain';
    this.mspId = process.env.FABRIC_MSP_ID || 'Org1MSP';
    this.walletPath = process.env.FABRIC_WALLET_PATH || path.join(__dirname, '../../wallet');
  }

  // Initialize blockchain connection
  async initialize() {
    try {
      // Create wallet instance
      this.wallet = await Wallets.newFileSystemWallet(this.walletPath);
      
      // Load connection profile (this would be generated by Fabric network)
      this.connectionProfile = this.getConnectionProfile();
      
      // Create gateway instance
      this.gateway = new Gateway();
      
      console.log('✅ Blockchain service initialized');
    } catch (error) {
      console.error('❌ Failed to initialize blockchain service:', error);
      throw error;
    }
  }

  // Connect to Fabric network
  async connect(userId = 'admin') {
    try {
      if (!this.gateway) {
        await this.initialize();
      }

      // Check if user identity exists in wallet
      const identity = await this.wallet.get(userId);
      if (!identity) {
        throw new Error(`Identity ${userId} not found in wallet`);
      }

      // Connect to gateway
      await this.gateway.connect(this.connectionProfile, {
        wallet: this.wallet,
        identity: userId,
        discovery: { enabled: true, asLocalhost: true }
      });

      // Get network and contract
      this.network = await this.gateway.getNetwork(this.channelName);
      this.contract = this.network.getContract(this.chaincodeName);

      console.log(`✅ Connected to Fabric network as ${userId}`);
      return true;
    } catch (error) {
      console.error('❌ Failed to connect to Fabric network:', error);
      throw error;
    }
  }

  // Disconnect from network
  async disconnect() {
    try {
      if (this.gateway) {
        await this.gateway.disconnect();
        this.gateway = null;
        this.network = null;
        this.contract = null;
      }
    } catch (error) {
      console.error('❌ Error disconnecting from network:', error);
    }
  }

  // Submit transaction to blockchain
  async submitTransaction(data, userId = 'admin') {
    try {
      await this.connect(userId);

      // Generate unique transaction ID
      const transactionId = this.generateTransactionId();
      
      // Create data hash for integrity
      const dataHash = this.createHash(data);
      
      // Prepare transaction data
      const transactionData = {
        id: transactionId,
        data: data,
        hash: dataHash,
        timestamp: new Date().toISOString(),
        submittedBy: userId
      };

      // Submit transaction to chaincode
      const result = await this.contract.submitTransaction(
        'CreateTransaction',
        JSON.stringify(transactionData)
      );

      console.log(`✅ Transaction ${transactionId} submitted to blockchain`);
      
      return {
        transactionId,
        hash: dataHash,
        fabricTxId: result.toString(),
        success: true
      };
    } catch (error) {
      console.error('❌ Failed to submit transaction:', error);
      throw error;
    } finally {
      await this.disconnect();
    }
  }

  // Query transaction from blockchain
  async queryTransaction(transactionId, userId = 'admin') {
    try {
      await this.connect(userId);

      const result = await this.contract.evaluateTransaction(
        'GetTransaction',
        transactionId
      );

      const transaction = JSON.parse(result.toString());
      return transaction;
    } catch (error) {
      console.error('❌ Failed to query transaction:', error);
      throw error;
    } finally {
      await this.disconnect();
    }
  }

  // Query all transactions
  async queryAllTransactions(userId = 'admin') {
    try {
      await this.connect(userId);

      const result = await this.contract.evaluateTransaction('GetAllTransactions');
      const transactions = JSON.parse(result.toString());
      return transactions;
    } catch (error) {
      console.error('❌ Failed to query all transactions:', error);
      throw error;
    } finally {
      await this.disconnect();
    }
  }

  // Validate transaction hash
  async validateTransaction(transactionId, expectedHash, userId = 'admin') {
    try {
      const transaction = await this.queryTransaction(transactionId, userId);
      return transaction.hash === expectedHash;
    } catch (error) {
      console.error('❌ Failed to validate transaction:', error);
      return false;
    }
  }

  // Generate unique transaction ID
  generateTransactionId() {
    return `tx_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
  }

  // Create SHA256 hash of data
  createHash(data) {
    return crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');
  }

  // Get connection profile (mock implementation)
  getConnectionProfile() {
    // In a real implementation, this would load the actual connection profile
    // generated by your Fabric network setup
    return {
      name: 'agrichain-network',
      version: '1.0.0',
      client: {
        organization: 'Org1',
        connection: {
          timeout: {
            peer: {
              endorser: '300'
            }
          }
        }
      },
      organizations: {
        Org1: {
          mspid: 'Org1MSP',
          peers: ['peer0.org1.example.com'],
          certificateAuthorities: ['ca.org1.example.com']
        }
      },
      orderers: {
        'orderer.example.com': {
          url: 'grpc://localhost:7050'
        }
      },
      peers: {
        'peer0.org1.example.com': {
          url: 'grpc://localhost:7051'
        }
      },
      certificateAuthorities: {
        'ca.org1.example.com': {
          url: 'http://localhost:7054',
          caName: 'ca-org1'
        }
      }
    };
  }

  // Mock method to register user (in production, this would use Fabric CA)
  async registerUser(userId, role = 'client') {
    try {
      // Check if user already exists
      const userIdentity = await this.wallet.get(userId);
      if (userIdentity) {
        console.log(`User ${userId} already exists in wallet`);
        return true;
      }

      // In a real implementation, you would:
      // 1. Connect to Fabric CA
      // 2. Register user with CA
      // 3. Enroll user and get certificates
      // 4. Import identity to wallet

      // Mock identity for development
      const mockIdentity = {
        credentials: {
          certificate: '-----BEGIN CERTIFICATE-----\nMOCK_CERTIFICATE\n-----END CERTIFICATE-----',
          privateKey: '-----BEGIN PRIVATE KEY-----\nMOCK_PRIVATE_KEY\n-----END PRIVATE KEY-----'
        },
        mspId: this.mspId,
        type: 'X.509'
      };

      await this.wallet.put(userId, mockIdentity);
      console.log(`✅ User ${userId} registered in wallet`);
      return true;
    } catch (error) {
      console.error(`❌ Failed to register user ${userId}:`, error);
      throw error;
    }
  }
}

module.exports = new BlockchainService();